// Generated by CoffeeScript 1.4.0
(function() {
  var Point, animate, asPoint, canvas, clear, combineNeighborsOf, ctx, deadNeighbors, draw, expand, expandPoint, interval, neighborsInList, neighborsOf, nextGeneration, pointId, revived, size, survivors, toId, updateSize;

  size = 20;

  interval = 200;

  canvas = document.getElementById('canvas');

  ctx = canvas.getContext('2d');

  Point = (function() {

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.get = (function() {
      var repo;
      repo = {};
      return function(x, y) {
        var _name, _ref;
        return (_ref = repo[_name = toId(x, y)]) != null ? _ref : repo[_name] = new Point(x, y);
      };
    })();

    return Point;

  })();

  toId = function(x, y) {
    return "" + x + ", " + y;
  };

  updateSize = function() {
    var clientHeight, clientWidth, _ref;
    _ref = document.documentElement, clientWidth = _ref.clientWidth, clientHeight = _ref.clientHeight;
    canvas.width = clientWidth;
    return canvas.height = clientHeight;
  };

  expand = function(x, y) {
    var i, j;
    return _.flatten((function() {
      var _i, _results;
      _results = [];
      for (i = _i = -1; _i <= 1; i = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (j = _j = -1; _j <= 1; j = ++_j) {
            _results1.push([x + i, y + j]);
          }
          return _results1;
        })());
      }
      return _results;
    })(), true);
  };

  asPoint = function(_arg) {
    var x, y;
    x = _arg[0], y = _arg[1];
    return Point.get(x, y);
  };

  expandPoint = function(p) {
    return expand(p.x, p.y).map(asPoint);
  };

  combineNeighborsOf = function(list) {
    var p;
    return _.unique(_.flatten((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        p = list[_i];
        _results.push(neighborsOf(p));
      }
      return _results;
    })()));
  };

  pointId = function(_arg) {
    var x, y;
    x = _arg.x, y = _arg.y;
    return toId(x, y);
  };

  neighborsOf = _.memoize((function(point) {
    return _.without(expandPoint(point), point);
  }), pointId);

  neighborsInList = function(list, p) {
    return (_.intersection(list, neighborsOf(p))).length;
  };

  survivors = function(list) {
    return list.filter(function(p) {
      var _ref;
      return (2 <= (_ref = neighborsInList(list, p)) && _ref <= 3);
    });
  };

  deadNeighbors = function(list) {
    return _.difference(combineNeighborsOf(list), list);
  };

  revived = function(list) {
    return deadNeighbors(list).filter(function(p) {
      return neighborsInList(list, p) === 3;
    });
  };

  nextGeneration = function(list) {
    return _.union(survivors(list), revived(list));
  };

  window.requestAnimationFrame || (window.requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 1000 / 60);
  });

  clear = function() {
    return ctx.clearRect(0, 0, canvas.width, canvas.height);
  };

  draw = function(list) {
    var x, y, _i, _len, _ref;
    ctx.save();
    ctx.fillStyle = 'white';
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      _ref = list[_i], x = _ref.x, y = _ref.y;
      ctx.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);
    }
    return ctx.restore();
  };

  animate = function(list) {
    var animLoop, last, lst;
    lst = list;
    last = $.now();
    animLoop = function() {
      var time;
      if (typeof requestAnimationFrame === "function") {
        requestAnimationFrame(animLoop);
      }
      time = $.now();
      if (last + interval < time) {
        last = time;
        clear();
        draw(lst);
        return lst = nextGeneration(lst);
      }
    };
    return animLoop();
  };

  (function() {
    var max_x, max_y, _i, _ref, _results;
    window.onresize = updateSize;
    updateSize();
    max_x = Math.floor(canvas.width / size);
    max_y = Math.floor(canvas.height / size);
    return animate(_.unique((function() {
      _results = [];
      for (var _i = 0, _ref = Math.floor(max_x * max_y * 0.2); 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function() {
      return Point.get(_.random(0, max_x), _.random(0, max_y));
    })));
  })();

}).call(this);
