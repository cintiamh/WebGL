// Generated by CoffeeScript 1.4.0
(function() {
  var ASPECT, BLOCK_SIZE, Block, FAR, HEIGHT, MAX_DEPTH, NEAR, REFRESH_RATE, Shape, TABLE_DEPTH, TABLE_HEIGHT, TABLE_WIDTH, VIEW_ANGLE, WIDTH, addPoints, add_static_block, animate, block_colors, boundingBox, camera, canvas, check_shape_pos, currShape, instantiate_shape, points, renderer, scene, shapes, start_time, staticBlocks, stepTime;

  WIDTH = 600;

  HEIGHT = 600;

  REFRESH_RATE = 60;

  TABLE_WIDTH = 6;

  TABLE_HEIGHT = 6;

  TABLE_DEPTH = 20;

  MAX_DEPTH = 14;

  BLOCK_SIZE = WIDTH / TABLE_WIDTH;

  VIEW_ANGLE = 45;

  ASPECT = WIDTH / HEIGHT;

  NEAR = 0.1;

  FAR = 10000;

  stepTime = 1000;

  points = 0;

  staticBlocks = [];

  block_colors = [0x0000FF, 0x3333FF, 0x6565FF, 0x9999FF, 0xB2B2FF, 0xCBCBFF, 0xE5E5FF, 0xE5FFE5, 0xCBFFCB, 0xB2FFB2, 0x99FF99, 0x65FF65, 0x33FF33, 0x00FF00];

  shapes = [];

  currShape = null;

  canvas = $('#canvas');

  renderer = new THREE.WebGLRenderer;

  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  scene = new THREE.Scene;

  scene.add(camera);

  camera.position.z = TABLE_DEPTH * BLOCK_SIZE / 2 + 225;

  renderer.setSize(WIDTH, HEIGHT);

  canvas.append(renderer.domElement);

  boundingBox = new THREE.Mesh(new THREE.CubeGeometry(TABLE_WIDTH * BLOCK_SIZE, TABLE_HEIGHT * BLOCK_SIZE, TABLE_DEPTH * BLOCK_SIZE, TABLE_WIDTH, TABLE_HEIGHT, TABLE_DEPTH), new THREE.MeshBasicMaterial({
    color: 0xFFAA00,
    wireframe: true
  }));

  scene.add(boundingBox);

  Block = (function() {

    function Block(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.color = 0xFF0000;
      this.active = false;
      this.cube = null;
    }

    Block.prototype.setColor = function(color) {
      return this.color = color;
    };

    Block.prototype.draw = function() {
      this.active = true;
      this.cube = new THREE.SceneUtils.createMultiMaterialObject(new THREE.CubeGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), [
        new THREE.MeshBasicMaterial({
          color: 0xFFAA00,
          wireframe: true,
          transparent: true
        }), new THREE.MeshBasicMaterial({
          color: this.color
        })
      ]);
      this.calculate_pos();
      return scene.add(this.cube);
    };

    Block.prototype.print = function() {
      return console.log(this.cube.position.x + ", " + this.cube.position.y + ", " + this.cube.position.z);
    };

    Block.prototype.calculate_pos = function() {
      this.cube.position.x = (TABLE_WIDTH / 2 + (this.x - (TABLE_WIDTH - 0.5))) * BLOCK_SIZE;
      this.cube.position.y = -(TABLE_HEIGHT / 2 + (this.y - (TABLE_HEIGHT - 0.5))) * BLOCK_SIZE;
      return this.cube.position.z = (this.z - TABLE_DEPTH / 2 + 0.5) * BLOCK_SIZE;
    };

    Block.prototype.erase = function() {
      this.active = false;
      return scene.remove(this.cube);
    };

    return Block;

  })();

  Shape = (function() {

    function Shape(points) {
      this.blocks = points.map(function(_arg) {
        var x, y, z;
        x = _arg[0], y = _arg[1], z = _arg[2];
        return new Block(x, y, z);
      });
      this.position = {
        x: 0,
        y: 0,
        z: 0
      };
    }

    Shape.prototype.draw = function() {
      return this.blocks.forEach(function(b) {
        return b.draw();
      });
    };

    Shape.prototype.erase = function() {
      return this.blocks.forEach(function(b) {
        return b.erase();
      });
    };

    Shape.prototype.move = function(diffx, diffy, diffz) {
      return this.blocks.forEach(function(b) {
        b.x += diffx;
        b.y += diffy;
        b.z += diffz;
        return b.calculate_pos();
      });
    };

    Shape.prototype.set_position = function(posx, posy, posz) {
      this.position.x = posx;
      this.position.y = posy;
      this.position.z = posz;
      return this.blocks.forEach(function(b) {
        b.x += posx;
        b.y += posy;
        b.z += posz;
        return b.calculate_pos();
      });
    };

    Shape.prototype.rotate = function(dirx, diry, dirz) {
      var position;
      position = this.position;
      if (dirx !== 0) {
        this.blocks.forEach(function(b) {
          var temp;
          temp = b.y;
          b.y = (-(b.z - position.z)) * dirx + position.y;
          b.z = (temp - position.y) * dirx + position.z;
          return b.calculate_pos();
        });
      }
      if (diry !== 0) {
        this.blocks.forEach(function(b) {
          var temp;
          temp = b.x;
          b.x = (b.z - position.z) * diry + position.x;
          b.z = (-(temp - position.x)) * diry + position.z;
          return b.calculate_pos();
        });
      }
      if (dirz !== 0) {
        return this.blocks.forEach(function(b) {
          var temp;
          temp = b.x;
          b.x = (-(b.y - position.y)) * dirz + position.x;
          b.y = (temp - position.x) * dirz + position.y;
          return b.calculate_pos();
        });
      }
    };

    Shape.prototype.check_col = function() {
      var reboot;
      reboot = false;
      this.blocks.forEach(function(b) {
        if (b.z <= 0) {
          return reboot = true;
        }
      });
      if (reboot) {
        instantiate_shape();
        this.erase();
      }
      return this.move(0, 0, -1);
    };

    return Shape;

  })();

  instantiate_shape = function() {
    var index;
    index = Math.floor(Math.random() * 5);
    currShape = shapes[index];
    currShape.draw();
    return currShape.set_position(Math.floor(TABLE_WIDTH / 2), Math.floor(TABLE_HEIGHT / 2), MAX_DEPTH);
  };

  check_shape_pos = function() {
    return currShape.check_col();
  };

  addPoints = function(n) {
    return points += n;
  };

  add_static_block = function(x, y, z) {
    var block;
    block = new Block(x, y, z);
    block.setColor(block_colors[z]);
    block.draw();
    return staticBlocks.push(block);
  };

  renderer.render(scene, camera);

  shapes.push(new Shape([[-1, -1, 0], [-1, 0, 0], [0, -1, 0], [0, 0, 0]]));

  shapes.push(new Shape([[-1, -1, 0], [0, -1, 0], [0, 0, 0], [0, 1, 0]]));

  shapes.push(new Shape([[0, -2, 0], [0, -1, 0], [0, 0, 0], [0, 1, 0]]));

  shapes.push(new Shape([[-1, 0, 0], [0, -1, 0], [0, 0, 0], [1, 0, 0]]));

  shapes.push(new Shape([[-2, -1, 0], [-1, -1, 0], [-1, 0, 0], [0, 0, 0]]));

  start_time = $.now();

  instantiate_shape();

  animate = function(t) {
    if ($.now() - start_time >= stepTime) {
      start_time = $.now();
      check_shape_pos();
    }
    renderer.clear();
    renderer.render(scene, camera);
    $('#points').text(points);
    return window.requestAnimationFrame(animate, renderer.domElement);
  };

  animate($.now());

}).call(this);
